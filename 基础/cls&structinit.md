## 初始化器委托

初始化是为类、结构体或者枚举准备实例的过程。这个过需要给实例里的每一个存储属性设置一个初始值并且在新实例可以使用之前执行任何其他所必须的配置或初始化。

不同于 Objective-C 的初始化器，Swift 初始化器不返回值。

### 什么是初始化器委托

初始化委托器在值类型和引用类型中是不一样的

- 值类型(结构体和枚举)不支持继承，所以他它们的初始化器委托的过程相当简单，因为它们只能提供它们自己为另一个初始化器委托。

- 类有额外的责任来确保它们继承的所有存储属性在初始化期间都分配了一个合适的值。

初始化器`可以调用其他初始化器来执行部分实例的初始化`。这个过程，就是所谓的初始化器委托，避免了多个初始化器里冗余代码。

### 值类型的初始化器委托

```swift
struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    init() {}
    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
```
上面的Rect结构体共有三种初始化方法:

- init() 与默认初始化方法一致内部不会进行任何操作 origin和size都会默认为0
- init(origin: Point, size: Size) 与成员初始化器相同
- init(center: Point, size: Size) 通过外部传入的size和center计算出origin，然后委托init(origin: Point, size: Size)方法来初始化Rect

这种情况下，外部可以使用任何一种方法去初始化Rect这个类。

### 引用类型的初始化器

所有类的存储属性(包括从他父类继承的所有属性)都必须在初始化期间分配初始值

swift为引用类型定义了两种初始化器以确保所有的存储属性接受一个初始值，这些就是所谓的指定初始化器和便捷初始化器。

#### 指定初始化器和便捷初始化器

指定初始化器:

```swift
init(parameters) {
    statements
}
```

便捷初始化器:

```swift
convenience init(parameters) {
    statements
}
```

二者的区别和联系:

- 指定初始化器是主要的初始化器，而编辑初始化器是次要的，是可有可无的
- 指定初始化器是初始化开始并持续初始化过程到父类链的传送节点
- 每个类都至少有一个指定初始化器，在某些情况可以通过从父类继承一个或多个指定初始化器来满足
- 便捷初始化器可以调用指定初始化器来给指定的初始化器设置默认参数


#### 引用类型初始化器委托

swift在初始化器之间的委托调用有下面三个原则:

- 指定初始化器必须从他的直系父类调用指定初始化器
- 编辑初始化器必须从相同的类里调用另一个初始化器
- 便捷初始化器最终必须调用一个指定初始化器

总结下来就是: 指定初始化器必须总是向上委托，便捷初始化器必须总是横向委托，具体如下图:

![referType_initializerDelegation](https://github.com/LeeWongSnail/AdvancedSwift/raw/main/res/referType_initializerDelegation.png)

#### 两段式初始化

swift的类初始化是一个两段式的过程

swift执行四种安全检查来确保两段式初始化顺利完成:

##### 安全检查一

指定初始化器必须保证在向上委托给父类初始化器之前，其所在类引入的所有属性都要初始化完成。

我们可以理解为： 在调用父类的初始化之前，子类的所有存储属性必须初始化完成

##### 安全检查二

指定初始化器必须先向上委托父类初始化器，然后才能为继承的属性设置新值。如果不这样做，指定初始化器赋予的新值将被父类中的初始化器所覆盖。

我们可以理解为： 在调用父类的初始化方法之前，子类不可以修改父类的存储属性，否则即使修改也会被父类覆盖。

##### 安全检查三

便捷初始化器必须先委托同类中的其它初始化器，然后再为任意属性赋新值（包括同类里定义的属性）。如果没这么做，便捷构初始化器赋予的新值将被自己类中其它指定初始化器所覆盖。

由于便捷初始化器只能横向依赖且最终肯定会调用到指定初始化器，因此必须先让当前类和父类的初始化都完成后才可以进行当前类的修改。否则也可能会被覆盖。

##### 安全检查四

初始化器在第一阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用 self 作为值。

第一阶段完成前(即所有存储属性分配初始值前) 不能够使用功能self,包括获取属性或者调用实例方法，直到第一阶段结束类实例才完全合法。属性只能被读取，方法也只能被调用，直到第一阶段结束的时候，这个类实例才被看做是合法的。

#### 两段式

##### 阶段一

* 指定或便捷初始化器在类中被调用；
* 为这个类的新实例分配内存。内存还没有被初始化；
* 这个类的指定初始化器确保所有由此类引入的存储属性都有一个值。现在这些存储属性的内存被初始化了；
* 指定初始化器上交父类的初始化器为其存储属性执行相同的任务；
* 这个调用父类初始化器的过程将沿着初始化器链一直向上进行，直到到达初始化器链的最顶部；
* 一旦达了初始化器链的最顶部，在链顶部的类确保所有的存储属性都有一个值，此实例的内存被认为完全初始化了，此时第一阶段完成。

##### 阶段二

* 从顶部初始化器往下，链中的每一个指定初始化器都有机会进一步定制实例。初始化器现在能够访问 self 并且可以修改它的属性，调用它的实例方法等等；
* 最终，链中任何便捷初始化器都有机会定制实例以及使用 slef 。

##### 图示

![referType_twoPhaseInitialization](https://github.com/LeeWongSnail/AdvancedSwift/raw/main/res/referType_twoPhaseInitialization.png)

在这个例子中，初始化过程从一个子类的便捷初始化器开始。这个便捷初始化器还不能修改任何属性。它委托给了同一类里的指定初始化器。

指定初始化器确保所有的子类属性都有值，如安全检查1。然后它调用父类的指定初始化器来沿着初始化器链一直往上完成父类的初始化过程。

父类的指定初始化器确保所有的父类属性都有值。由于没有更多的父类来初始化，也就不需要更多的委托。

一旦父类中所有属性都有初始值，它的内存就被认为完全初始化了，第一阶段完成。

下图是相同的初始化过程在第二阶段的样子：

![referType_twoPhaseInitialization02_2x](https://github.com/LeeWongSnail/AdvancedSwift/raw/main/res/referType_twoPhaseInitialization02_2x.png)

现在父类的指定初始化器有机会来定制更多实例(尽管没有这种必要)。

一旦父类的指定初始化器完成了调用，子类的指定初始化器就可以执行额外的定制(同样，尽管没有这种必要)。

最后，一旦子类的指定初始化器完成，最初调用的便捷初始化器将会执行额外的定制操作。

#### 初始化器的继承和重写


Swift中let属性在init方法调用前就被调用了 那存储到哪个位置了呢？

为什么init方法中设置属性值不会调用监听器方法


